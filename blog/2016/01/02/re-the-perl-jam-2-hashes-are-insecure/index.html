<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#">
    <head>
        <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
        <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
        <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
        <link href="/theme/css/statocles-bootstrap.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
        <title>Re: The Perl Jam 2: Hashes are Insecure - KENTNL's Blog</title>
        <meta content="Statocles 0.066" name="generator">
        <meta content="https://avatars0.githubusercontent.com/u/44790?v=3&amp;s=400" property="og:image">

        <link href="/theme/plugin/highlight/default.css" rel="stylesheet" type="text/css">
    </head>
    <body>
        <header>
            <nav class="navbar navbar-default navbar-static-top" role="navigation">
                <div class="container">
                <!-- Brand and toggle get grouped for better mobile display -->
                    <div class="navbar-header">
                        <button class="navbar-toggle" data-target="#top-navbar-collapse-1" data-toggle="collapse" type="button">
                            <span class="sr-only">Toggle navigation</span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </button>
                        <a class="navbar-brand" href="/">KENTNL&#39;s Blog</a>
                    </div>
                    <!-- Collect the nav links, forms, and other content for toggling -->
                    <div class="collapse navbar-collapse" id="top-navbar-collapse-1">
                        <ul class="nav navbar-nav">
                            <li><a href="/">Blog</a></li>
                        </ul>
                        
                    </div>
                </div>
            </nav>
            
        </header>
        <div class="main container">
            <div class="row">

    <div class="col-md-9">
        <main>
            <header>
                <h1>Re: The Perl Jam 2: Hashes are Insecure</h1>
                <p class="tags">Tags:
                    <a href="/blog/tag/perl/" rel="tag">perl</a>
                    <a href="/blog/tag/the-perl-jam-2/" rel="tag">the perl jam 2</a>
                </p>

                <aside>
                    <p><time datetime="2016-01-02">
                        Posted on 2016-01-02
                    </time>
                    </p>
                </aside>


            </header>
            <section id="section-1">
                <p>This is part 3 in a <a href="/blog/tag/the-perl-jam-2">series</a> of responses to
<a href="https://www.youtube.com/watch?v=eH_u3C2WwQ0">Netanel Rubin&#39;s Presentation: The Perl Jam 2</a>,
for reasons explained in <a href="/blog/2015/12/31/re-the-perl-jam-2-cgi-sucks/">Part 1</a></p>

<p>In his original presentation, Netanel over focused on the assumption that we treat
Hashes and other arbitrary data structures as safe by default.</p>

<p>This is not really true, however, when watching him talk about it, I realised
he was right in a sense, just ... not how he imagined.</p>

<h2 id="hash_keys_are_a_potential_security_risk_">Hash Keys are a Potential Security Risk.<a class="toplink" href="#top">^</a><a class="permalink" href="#hash_keys_are_a_potential_security_risk_">⚓</a></h2>

<p>Under taint mode, strings from external sources are marked &quot;tainted&quot; until somebody manually untaints them.</p>

<p>And then any tainting-sensitive function calls can raise a fatal exception if they are passed sensitive data.</p>

<p>For instance, Take the following JSON file</p>

<pre><code class="hljs">{ <span class="hljs-string">&quot;DROP TABLES *&quot;</span>: <span class="hljs-string">&quot;DROP TABLES *&quot;</span> }
</code></pre>

<p>Now, using the following script:</p>

<pre><code class="hljs"><span class="hljs-keyword">use</span> <span class="hljs-keyword">strict</span>;
<span class="hljs-keyword">use</span> <span class="hljs-keyword">warnings</span>;
<span class="hljs-keyword">use</span> <span class="hljs-function">JSON::MaybeXS</span>;
<span class="hljs-keyword">use</span> <span class="hljs-function">Path::Tiny</span> qw( path );

<span class="hljs-keyword">my</span> <span class="hljs-type">$structure</span> = decode_json(path(&#39;<span class="hljs-string">/tmp/evil.json</span>&#39;)-&gt;slurp_raw);
<span class="hljs-function">system</span>(&quot;<span class="hljs-string">echo </span>&quot; . <span class="hljs-function">join</span> q[], <span class="hljs-function">values</span> <span class="hljs-type">%</span>{<span class="hljs-type">$structure</span>} );
</code></pre>

<p>This example demonstrates that the JSON back-end faithfully preserved taintness
of the external data, and the code fails as expected.</p>

<pre><code class="hljs">$ env -i perl -T /tmp/json.pl
Insecure dependency <span class="hljs-keyword">in</span> system <span class="hljs-keyword">while</span> running with -T switch at /tmp/json.pl line 7.
</code></pre>

<p>However, hash keys are inherently different:</p>

<pre><code class="hljs">- system(&quot;echo &quot; . join q[], values %{$structure} );
<span class="hljs-string">+ system(&quot;echo &quot; . join q[], keys   %{$structure} );</span><span class="hljs-string">
</span></code></pre>

<p>And now we have a problem:</p>

<pre><code class="hljs">$ env -i perl -T /tmp/json.pl
DROP TABLES blog page site.yml static theme
</code></pre>

            </section>
            <section id="section-2">
                <p>Now this is not necessarily a problem if you apply clean code practices.</p>

<p>As long as you make sure everything the user gave you is well sanitized, and you use Bound-Parameter style value passing to literally
every API you use, then you might be OK.</p>

<p>But Taint mode basically exists as a fall-back defense to guard against developers failing to vet all the inputs, so that if
you missed something, Perl still has an opportunity to save the day.</p>

<p>But people can also be needlessly lazy and rely entirely on Perl to save the day, when Perl is not psychic.</p>

<p>And worse, you can be using Taint mode, but you could either be unintentionally untainting sensitive data, or intentionally untaining data
but untainting it incorrectly, leaving exploitable code through to your system.</p>

<p>Here, &quot;Value spent time in a Hash Key&quot; transparently untaining data can leverage itself to be a weak point.</p>

<h2 id="how_do_we_fix_it">How Do We Fix It<a class="toplink" href="#top">^</a><a class="permalink" href="#how_do_we_fix_it">⚓</a></h2>

<h3 id="considerations">Considerations<a class="toplink" href="#top">^</a><a class="permalink" href="#considerations">⚓</a></h3>

<h4 id="performance">Performance<a class="toplink" href="#top">^</a><a class="permalink" href="#performance">⚓</a></h4>

<p>There&#39;s a big blocker inhibiting our ability to make Hash Keys retain taintedness.</p>

<p>And its based on how Hash data structures underly a significant proportion of the Perl Language.</p>

<p>Not only do Anonymous Hash References use Hashes as their underlying model, but so does the entire <code>package Foo::</code> namespace hierarchy,
which includes the symbol tables that methods and global variables are stored in.</p>

<p>Which means any changes we make to the Hash Data structure to preserve taint bits will incur a significant performance overhead under Taint Mode.</p>

<p>This would also cause a performance decrease for All Perl, even when <em>not</em> running in Taint Mode.</p>

<h4 id="implementation_challenges">Implementation Challenges<a class="toplink" href="#top">^</a><a class="permalink" href="#implementation_challenges">⚓</a></h4>

<p>How do we want this to behave?</p>

<pre><code class="hljs"><span class="hljs-keyword">my</span> <span class="hljs-type">$hash</span> = {};
<span class="hljs-type">$hash</span>-&gt;{ taint(&quot;<span class="hljs-string">Hello</span>&quot;) } = &quot;<span class="hljs-string">World</span>&quot;;
<span class="hljs-type">$hash</span>-&gt;{ &quot;<span class="hljs-string">Hello</span>&quot; } = &quot;<span class="hljs-string">Earth</span>&quot;;

<span class="hljs-comment"># Is $value tainted or not here?</span><span class="hljs-comment">
</span><span class="hljs-keyword">my</span> (<span class="hljs-type">$value</span>,) = <span class="hljs-function">keys</span> <span class="hljs-type">%</span>{<span class="hljs-type">$hash</span>};
<span class="hljs-comment"># How many keys are there exactly anyway, should we consider a tainted key</span><span class="hljs-comment">
</span><span class="hljs-comment"># and its untainted companion to be identical or different keys?</span><span class="hljs-comment">
</span><span class="hljs-keyword">my</span> <span class="hljs-type">$n_keys</span> = <span class="hljs-function">scalar</span> <span class="hljs-function">keys</span> <span class="hljs-type">%</span>{<span class="hljs-type">$hash</span>};
</code></pre>

<h4 id="backwards_compatibility">Backwards Compatibility<a class="toplink" href="#top">^</a><a class="permalink" href="#backwards_compatibility">⚓</a></h4>

<p>Because &quot;Hash-Keys-Remove-Taint&quot; has been a thing for so long, there is very likely code in production
that is intentionally relying on this behaviour.</p>

<p>How do we fix this without making a lot of existing and correct code suddenly become broken?</p>

<h3 id="suggestions">Suggestions<a class="toplink" href="#top">^</a><a class="permalink" href="#suggestions">⚓</a></h3>

<h4 id="tainted_hashes">Tainted Hashes<a class="toplink" href="#top">^</a><a class="permalink" href="#tainted_hashes">⚓</a></h4>

<p>I would probably propose an option that allows taintedness to become a property of a hash,
instead of merely a property of the strings contained in that hash.</p>

<p>Tools like JSON decoders would explicitly mark any hash constructed from tainted data to be implicitly
tainted, and then hash internals don&#39;t care about taintedness on a per-key/per-value level, and just re-tag
everything that came out of a tainted hash ( either by calls to keys or values ) became tainted by default.</p>

<p>But sadly, this doesn&#39;t mitigate the potential performance negatives of adding the feature, because
there still has to be an &quot;Am I tainted? -&gt; Return tainted value&quot; stage, and that code path would still
have to be there for all the package/stash lookups.</p>

<p>You could probably bodge together something that approximates this with <code>tie</code>, but <code>tie</code> is almost always
more poison than cure.</p>

<h4 id="lexically_applied_hash_tainting">Lexically Applied Hash Tainting<a class="toplink" href="#top">^</a><a class="permalink" href="#lexically_applied_hash_tainting">⚓</a></h4>

<p>It seems possible to me that a pragma could be developed that doesn&#39;t affect the handling of Hashes intrinsically,
but lexically changes how hash-access OPs are compiled in its context.</p>

<p>And it seems to me you could leverage such a thing to only apply to hash access calls on variables, as opposed to on GLOBs ( Package/Stashes )</p>

<pre><code class="hljs"><span class="hljs-keyword">use</span> t<span class="hljs-function">ainted::hashes</span>;

<span class="hljs-keyword">Package</span>::<span class="hljs-function">foo::method</span>(); <span class="hljs-comment"># Uses native Hash Access ops.</span><span class="hljs-comment">
</span>
<span class="hljs-type">$ref</span>-&gt;{key} <span class="hljs-comment"># uses taint safe ops if tainting is enabled.</span><span class="hljs-comment">
</span></code></pre>

<p>You&#39;d need to have some sort of semantics in play so you can handle the taintedness of hashes declared in other contexts,
for instance, you might assume any hash that hasn&#39;t been seen by a tainted::hashes pragma and hasn&#39;t been marked &quot;Safe&quot;
is inherently &quot;Unsafe&quot;.</p>

<p>And then you could potentially &quot;turn on&quot; that feature by default in some future perl release under tainting,
or at least, turn it on as a feature with <code>use 5.${FUTURE}</code>.</p>

<h4 id="call_for_suggestions">Call For Suggestions<a class="toplink" href="#top">^</a><a class="permalink" href="#call_for_suggestions">⚓</a></h4>

<p>Clearly neither of those solutions are entirely elegant and may have serious road stops. And I honestly know almost
nothing about XS when it comes to the implementation details in Perl Guts to know what is possible and what isn&#39;t.</p>

<p>So if any readers out there have some good ideas, there&#39;s a P5P who&#39;s accepting patches if they seem reasonable and the technical
costs are affordable.</p>

<h2 id="comments">Comments<a class="toplink" href="#top">^</a><a class="permalink" href="#comments">⚓</a></h2>

<p>Please direct any feedback or corrections <a href="https://www.reddit.com/r/perl/comments/3zemb5/re_the_perl_jam_2_hashes_are_insecure/">to the Reddit thread</a>. Alternatively, message me on irc:</p>

<ul>
<li>irc.perl.org u:kentnl</li>
<li>irc.freenode.org u:kent\n</li>
</ul>

<p>Or if you want, you can <a href="https://github.com/kentfredric/kentfredric.github.io/pulls">patch the blog yourself</a>
or <a href="https://github.com/kentfredric/kentfredric.github.io/issues">file a bug on it</a></p>

            </section>
        </main>


    </div>

    <div class="col-md-3">
        
        <nav id="tags">
            <h1>Tags</h1>
            <ul class="list-inline">
                <li><a href="/blog/tag/perl/">perl</a></li>
                <li><a href="/blog/tag/the-perl-jam-2/">the perl jam 2</a></li>
            </ul>
        </nav>
    </div>

</div>

        </div>
        <footer>
            
            <div class="container tagline">
                <a href="http://preaction.me/statocles">Made with Statocles</a><br>
                <a href="http://www.perl.org">Powered by Perl</a>
            </div>
        </footer>
    </body>
</html>
