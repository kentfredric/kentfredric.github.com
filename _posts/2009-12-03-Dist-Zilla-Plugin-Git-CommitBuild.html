---
layout: article
title: Dist-Zilla-Plugin-Git-CommitBuild
---
<p>I've contemplated this for a while. I might get a round tuit, and do this myself, so this blog entry is here to jog my brain, jot down ideas, possibly collect info.</p>
<p>If you look at the repositories behind any of my CPAN dists ( well, most of them ), you'll see I maintain both release and source branches for the entire history ( <a href="http://github.com/kentfredric/ELF-Extract-Sections/network">http://github.com/kentfredric/ELF-Extract-Sections/network</a> ), and more recently, maintaining a sort of "pre-release/release" sub-system, where stuff I build just for testing/preview purposes may have a life on their own branch, sort of like release candidates.&nbsp; </p>
<p>This is essentially to provide a branch that is containing a full copy of all the generated code, as posted on CPAN, as opposed to the source that it is generated from, for posterity reasons mostly, and so I can deprecate versions on CPAN for incompatibility reasons one day , and people won't be left in the lurch to get an identical copy of it somewhere, as it will always be in the git history, just grab the right tag and you're set. </p>
<p>They could always use the backpan, but that has 2 caveats in my experience.</p>
<p>
  <ol>
  <li>
    <p>No diff mechanism. This feature is very important to people who do release maintenance for distributions, as its the only good way to conclusively see what exactly changed between 2 consecutive versions, in order to update their internal dependency data that controls the shipping of the built copies. </p>
    <p>For this reason also, I loathe every time somebody deletes an older copy of their dist when its not been outdated for &lt; 3 months, because it can take that long to notice that the shipped copy is outdated and for somebody to request a version bump. Not being able to use CPAN's <code>diff</code> feature makes this task much more challenging. ( At least for me, for that is how I do my work-flow, and I kind-of help out lots with <a href="http://git.overlays.gentoo.org/gitweb/?p=proj/perl-overlay.git;a=summary">gentoo's perl-experimental overlay</a> ).</p>
  </li>
  <li>
  <p>Sometimes, versions live too short a time to be backed up on backpan. This is very problematic, for the above reason, and for the reason is you have no historical record of what happened outside the <code>Changes</code>, and the original commit history. You could probably argue there's no reason to ever want these version that never made it to backpan, and you'd probably be right.</p>
  </li>
</ol>
</p>
<p>So to remedy this problem, here is what I do.</p>
<p>
  <ol>
    <li>
      <p>Commit, and tag the exact source tree that was used to generate the released code in the notation <code>%v-source</code>. 
    This theoretically guarantees that anyone can check out that exact same release, run "<code>dzil release</code>", and produce more or less the exact same output, with the only difference possibly being the version numbers emitted if you're using an <a href="http://search.cpan.org/dist/Dist-Zilla/lib/Dist/Zilla/Plugin/AutoVersion.pm"><code>[AutoVersion]</code></a> or <a href="http://search.cpan.org/dist/Dist-Zilla-Plugin-AutoVersion-Relative/lib/Dist/Zilla/Plugin/AutoVersion/Relative.pm"><code>[AutoVersion::Relative]</code></a> plugin.
      </p>
      <p>
        Here is the code snippet I use to do this that uses <a href="http://jquelin.blogspot.com/">Jerome Quelin's</a> 
        <a href="http://search.cpan.org/dist/Dist-Zilla-Plugin-Git/"><code>[Git]</code></a> plugin suite.
        </p>

      <blockquote>{% highlight ini %}
[Git::Check]
filename = Changes

[NextRelease]

[Git::Tag]
filename = Changes
tag_format = %v-source

[Git::Commit]
{% endhighlight %}
</blockquote>
<p>This Order is important. In the Build phase, <code>[NextRelease]</code> formats the <code>Changes</code> template into an exportable form, and puts the datestamp in it.</p>
<p>In the pre-release phase, <code>[Git::Check]</code> makes sure theres nothing in the tree that isn't committed.</p>
<p><code>[UploadToCpan]</code> uploads the dist to CPAN, and the post-release phase kicks in.</p>
<p><code>[NextRelease]</code> then kicks in again, and reformats the <code>Changes</code> so it resembles the previously released <code>Changes</code> except with that <code>{{$NEXT}}</code> stuff in it ready for hacking on.</p>
<p><code>[Git::Tag]</code> tags the last commit ( that is, not the current tree with the modified <code>Changes</code>, that's not committed yet, but the commit that it was at still when we released ) with <code>%v-source</code>, and then <code>[Git::Commit]</code> commits the updated <code>Changes</code> as a new commit ( with a copy of the first segment of the <code>Changes</code> file as its commit message )</p>
</li>
<li>
  <p>Have a separate commit history just for releases to be copied into.</p>
  <blockquote>{% highlight bash %}git symbolic-ref HEAD refs/heads/releases {%endhighlight%}</blockquote>
  <p>The first commit of this is built, generally from the first releases files. At present, I do this first release as so:</p>
  <blockquote>{% highlight bash %}rsync -avp Some-Dist-Name-0.010101/ ./ {%endhighlight%}</blockquote>
  <p>then weed out all the files I'm pretty sure weren't in the generated tree by hand. ( I had a some code that did it all with <code>rsync</code>, and had an ignore list so that the <code>--delete-after </code>argument didn't accidentally erase all of <code>.git</code>, which would be very sad, but I accidentally deleted it :[ )</p>
  <p>This tree now represents an exact copy of the generated code, and it is committed as follows:</p>
  <blockquote>{%highlight bash%}git commit -m "Build of 0deadbeef0, version 0.010101 on cpan" {%endhighlight%}</blockquote>
  <p>or similar, to assure that every commit on the release branch, is a direct derivative of another commit on the source branch, and there's an intrinsic link between them.&nbsp; ( I avoided having a direct link, because that gives cleaner histories ).</p>
</li>
<li>
  <p>That commit is tagged as the released version, ( ie: <code>0.010101</code> )</p>
</li>
</ol>
<p>Now all this is wonderfully Tedious. At present, the best I have <a href="http://gist.github.com/247201">a script</a> that makes the "commit and tag" phase on the release branch reasonably painless, but what I want to do, is have a nice way, to automate all of the above, every single bit of it, with a plugin.</p>
<p>Here is some proposed syntax.</p>
<blockquote>{% highlight ini %}[Git::CommitBuild / prerelease ]
branch = prereleases
autocreate = 1
phase = build

[Git::CommitBuild / release]
branch = releases
autocreate = 1
phase = after_release
{% endhighlight %}
</blockquote>
<p>Why this notation? well, I guess it just seems the right amount of flexible to me. the text after the / is totally optional, and its just a way to let dzil differentiate between copies of the same plugin.</p>
<p><code>branch</code> is to tell it what git branch to work with. I figgured I could just use the name part after the /, but it seemed nasty to me ( spaces for instance ). At very best, it could default to that value if <code>branch =</code> is not specified.</p>
<p><code>autocreate = 1</code> would magick the branch out of fat air the first time you tried to commit to it and it wasn't there. This would be off by default, as it could be annoying to you if you'd already created another branch with a different name for that purpose, and typoed and it created another branch. This way it fails instead of annoying you.</p>
<p><code>phase =</code> build is sadly the most scary bit I'm trying to eliminate the stink of. Essentially, I have one plugin that does only one thing, but there are 2 different times I may want to run it at. ( And there are possibly more places people might want to say "stop the build, store this somewhere, then continue" ).</p>
<p>In the above scenario, 'prerelease' I envisage as only getting run when I call "<code>dzil build</code>" explicitly. <strong>NOT</strong> '<code>dzil test</code>' and <strong>NOT</strong> '<code>dzil release</code>', only '<code>dzil build</code>'.</p>
<p>
Also, Ideally, the whole commit phase should be done, magically, entirely in memory, with some magical git magic, to eliminate the whole "write it out to the filesystem before creating the actual commit data" part of the equation, so that nowhere anywhere does there transpire something like </p>
<blockquote>
{% highlight bash %}
git checkout releases
git commit stuff
git checkout master
{% endhighlight %}
</blockquote>
<p>which causes anarchy in the event anything else happened to be using the file-system. </p>
<p>Thoughts/Suggestions anyone?</p>

